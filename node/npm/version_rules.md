# 版本规则

[https://semver.org/lang/zh-CN/](https://semver.org/lang/zh-CN/)
[https://github.com/npm/node-semver](https://github.com/npm/node-semver)

基本规则
语义化版本控制，顾名思义，就是让版本号更具有语义，可以传达出关于软件本身的一些重要信息而不只是简单的一串数字。

基本版本格式
1
主版本号（Major）.次版本号（Minor）.修订号（Patch）
每个部分都为整数（>=0），按照递增的规则改变。

版本号递增规则
主版本号（Major）：当你做了不兼容的 API 修改
次版本号（Minor）：当你做了向下兼容的功能性新增
修订号（Patch）：当你做了向下兼容的问题修正
先行版本号及版本编译信息可以加到基本版本格式的后面，作为延伸
先行版本号由首位的连接号”-“、标识符号（由 ASCII 码的英文数字和连接号标识符[0-9A-Za-z-]组成）、句点”.“组成。如 1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。先行版的优先级低于相关联的标准版本
版本编译信息由首位的一个加号和一连串以句点分隔的标识符号（由 ASCII 码的英文数字和连接号标识符[0-9A-Za-z-]组成）组成。如 1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。判断版本优先层级时，版本编译信息可以被忽略
如何比较版本高低
判断优先层级时，必须把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较。由左到右依次比较每个标识符号，第一个差异值用来决定优先层级（其中字母连接号以 ASCII 排序进行比较、其他都相同时栏位多的先行版本号优先级较高）。如：

1
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。

范围规则
<空>
锁定版本号

1.0.0: 锁定了版本只能为 1.0.0
<、<=、>、>=、=
指定版本范围，甚至可以通过||组合多个比较器

=1.2.7 <1.3.0 中包括 1.2.7、1.2.8、1.2.99 等等，但不包括 1.2.6、1.3.0 或 1.1.0 等等
1.2.7 || >=1.2.9 <2.0.0 中包括 1.2.7、1.2.9、1.4.6 等等，但不包括 1.2.8 或 2.0.0 等等 -
连字符表示版本号范围，表示的是一个闭区间

1.2.3 - 2.3.4 相当于 >=1.2.3 和 <=2.3.4

x、X、\*

可以替代主版本号.次版本号.修订号三段中任意一段，表示该位置版本号没有限制；另外缺省三段中任意一段与用 x、X 或\*替换该段效果相同

- 相当于 >=0.0.0，表示任何版本号
- 1.X 或 1.x 相当于 >=1.0.0 <2.0.0，匹配到主版本号
- 1.2.\_ 相当于 >=1.2.0 <1.3.0，匹配到主版本号和次版本号
- ""（空字符串） 相当于 \_ ，即相当于 >=0.0.0
- 1 相当于 1.x.x，即相当于 >=1.0.0 <2.0.0
- 1.2 相当于 1.2.x，即相当于 >=1.2.0 <1.3.0

~
允许小版本迭代

- 如果有缺省值，缺省部分任意迭代；
- 如果没有缺省值，只允许补丁即修订号（Patch）的迭代
  eg.:

- ~1.2.3：>=1.2.3 <1.3.0
- ~1.2：>=1.2.0 < 1.3.0（相当于 1.2.x）
- ~1：>=1.0.0 <2.0.0（相当于 1.x）
- ~0.2.3：>=0.2.3 <0.3.0
- ~0.2：>=0.2.0 <0.3.0（相当于 0.2.x）
- ~0：>=0.0.0 <1.0.0（相当于 0.x）
- ~1.2.3-beta.2：>=1.2.3-beta.2 <1.3.0（注意，在 1.2.3 版本中，允许使用大于等于 beta.2 的先行版本号，而除 1.2.3 之外的版本号不允许使用先行版本号，所以此处 1.2.3-beta.4 是允许的，而 1.2.4-beta.2 是不允许的）

^
允许大版本迭代

- 允许从左到右的第一段不为 0 那一版本位+1 迭代（左闭右开）；
- 如果有缺省值，且缺省值之前没有不为 0 的版本位，则允许缺省值的前一位版本+1 迭代
  eg.:

- ^1.2.3：>=1.2.3 <2.0.0
- ^0.2.3：>=0.2.3 <0.3.0
- ^0.0.3：>=0.0.3 <0.0.4
- ^1.2.x：>=1.2.0 <2.0.0
- ^0.0.x：>=0.0.0 <0.1.0
- ^0.0：>=0.0.0 <0.1.0
- ^1.x：>=1.0.0 <2.0.0
- ^0.x：>=0.0.0 <1.0.0
- ^1.2.3-beta.2：>=1.2.3-beta.2 <2.0.0（注意，在 1.2.3 版本中，允许使用大于等于 beta.2 的先行版本号，而除了 1.2.3 之外的版本号不允许使用先行版本号，所以此处 1.2.3-beta.4 是允许的，而 1.2.4-beta.2 是不允许的）；
- ^0.0.3-beta：>=0.0.3-beta <0.0.4（同上，此处 0.0.3-pr.2 是允许的）

锁定（控制）版本
看到这，聪明的你一定想到了 package-lock.json 或是 yarn.lock。

在 npm 的版本>=5.1 的时候，package-lock.json 文件是自动打开的，意味着会自动生成，
package-lock.json（官方文档）可以理解为/node_modules 文件夹内容的 json 映射，并能够感知 npm 的安装/升级/卸载的操作。可以保证在不同的环境下安装的包版本保持一致。听上去很不错哈，实际使用中，大部分它的表现确实不错，可是如上述问题：我手动修改了 package.json 文件内依赖的版本，package-lock.json 就没那么聪明（至少目前是，未来会不会变聪明就不可知了），且不会变化。
